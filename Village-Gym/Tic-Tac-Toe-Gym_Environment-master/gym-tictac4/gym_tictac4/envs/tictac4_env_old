import gym
from gym import error, spaces, utils
from gym.utils import seeding

############################################################
# Costants of the game
############################################################
CODE_MARK_MAP = {0: ' ', 1: 'O', 2: 'X'}
NUM_LOC = 9
O_REWARD = 1
X_REWARD = -1
NO_REWARD = 0

############################################################
# Auxiliary function
############################################################
# Converts a code to mark -> 0:' ', 1:'O', 2:'X'
############################################################
def tomark(code):
    return CODE_MARK_MAP[code]
############################################################
# Converts a a mark to code -> 'O':1, 'X': 2
############################################################
def tocode(mark):
    return 1 if mark == 'O' else 2
############################################################
# Return next _mark (to play)
############################################################
def next_mark(mark):
    return 'X' if mark == 'O' else 'O'
############################################################
# Return agent by correspondent mark
############################################################
def agent_by_mark(agents, mark):
    for agent in agents:
        if agent.mark == mark:
            return agent
############################################################
# Execute an action and returns resulted state
############################################################
def after_action_state(state, action):
    """Execute an action and returns resulted state.
    Args:
        state (tuple): Board status + mark
        action (int): Action to run
    Returns:
        tuple: New state
    """

    board, mark = state
    nboard = list(board[:])
    nboard[action] = tocode(mark)
    nboard = tuple(nboard)
    return nboard, next_mark(mark)
############################################################
# Return game status by current board status.
############################################################
def check_game_status(board):
    """Return game status by current board status.
    Args:
        board (list): Current board state
    Returns:
        int:
            -1: game in progress
            0: draw game,
            1 or 2 for finished game(winner mark code).
    """
    for t in [1, 2]:
        for j in range(0, 9, 3):
            if [t] * 3 == [board[i] for i in range(j, j+3)]:
                return t
        for j in range(0, 3):
            if board[j] == t and board[j+3] == t and board[j+6] == t:
                return t
        if board[0] == t and board[4] == t and board[8] == t:
            return t
        if board[2] == t and board[4] == t and board[6] == t:
            return t

    for i in range(9):
        if board[i] == 0:
            # still playing
            return -1

    # draw game
    return 0

class TicTac4(gym.Env):
    metadata = {'render.modes': ['human']}



    def __init__(self, alpha = 0.02):
        super(TicTac4, self).__init__()
        self.action_space = spaces.Discrete(9)
        self.observation_space = spaces.Discrete(9)
        self.alpha = alpha
        self.state = []
        for i in range(3):
            self.state += [[]]
            for j in range(3):
                self.state[i] += ["-"]
        self.counter = 0
        self.done = 0
        self.add = [0, 0]
        self.reward = 0
        
       
        self.reset()
        # observation_space -> environment's data to be observed by the agent
        # Example for using image as input:
        # self.observation_space = spaces.Box(low=0, high=255, shape=
                    #(HEIGHT, WIDTH, N_CHANNELS), dtype=np.uint8)
    
    def set_start_mark(self, mark):
        self.start_mark = mark
    
    def check(self):

        if(self.counter<5):
            return 0
        for i in range(3):
            if(self.state[i][0] != "-" and self.state[i][1] == self.state[i][0] and self.state[i][1] == self.state[i][2]):
                if(self.state[i][0] == "o"):
                    return 1
                else:
                    return 2
            if(self.state[0][i] != "-" and self.state[1][i] == self.state[0][i] and self.state[1][i] == self.state[2][i]):
                if(self.state[0][i] == "o"):
                    return 1
                else:
                    return 2
        if(self.state[0][0] != "-" and self.state[1][1] == self.state[0][0] and self.state[1][1] == self.state[2][2]):
            if(self.state[0][0] == "o"):
                return 1
            else:
                return 2
        if(self.state[0][2] != "-" and self.state[0][2] == self.state[1][1] and self.state[1][1] == self.state[2][0]):
            if(self.state[1][1] == "o"):
                return 1
            else:
                return 2



    def step(self, target):
        if self.done == 1:
            print("Game Over")
            return [self.state, self.reward, self.done, self.add]
        elif self.state[int(target/3)][target%3] != "-":
            # print("Invalid Step, action: {}".format(target))
            return [self.state, self.reward, self.done, self.add]
        else:
            if(self.counter%2 == 0):
                self.state[int(target/3)][target%3] = "o"
            else:
                self.state[int(target/3)][target%3] = "x"
            self.counter += 1
            if(self.counter == 9):
                self.done = 1;
            #self.render()

        win = self.check()
        if(win):
            self.done = 1;
            print("Player ", win, " wins.", sep = "", end = "\n")
            self.add[win-1] = 1;
            if win == 1:
                self.reward = 100
            else:
                self.reward = -100

        return [self.state, self.reward, self.done, self.add]

    def reset(self):
        for i in range(3):
            for j in range(3):
                self.state[i][j] = "-"
        self.counter = 0
        self.done = 0
        self.add = [0, 0]
        self.reward = 0
        return self.state

    def render(self):
        for i in range(3):
            for j in range(3):
                print(self.state[i][j], end = " ")
            print("")
